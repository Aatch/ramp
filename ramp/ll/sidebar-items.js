initSidebarItems({"fn":[["add",""],["add_1",""],["add_n","Adds the `n` least signficant limbs of `xp` and `yp`, storing the result in {wp, n}. If there was a carry, it is returned."],["addmul_1","Multiplies the `n` least-signficiant digits of `xp` by `vl` and adds them to the `n` least-significant digits of `wp`. Returns the highest limb of the result."],["and_n","Performs a bitwise \"and\" (`&`) of the n least signficant limbs of `xp` and `yp`, storing the result in `wp`"],["and_not_n","Performs a bitwise and of the n least signficant limbs of `xp` and `yp`, with the limbs of `yp` being first inverted. The result is stored in `wp`."],["cmp","Compares the `n` least-significant limbs of `xp` and `yp`, returning whether {xp, n} is less than, equal to or greater than {yp, n}"],["copy_decr","Copies the `n` limbs from `src` to `dst` in a decremental fashion."],["copy_incr","Copies the `n` limbs from `src` to `dst` in an incremental fashion."],["copy_rest","Copies the `n - start` limbs from `src + start` to `dst + start`"],["decr",""],["divide_by_zero","Called when a divide by zero occurs."],["divrem","Divides {np, ns} by {dp, ds}. If ns <= ds, the quotient is stored in {qp, 1}, otherwise the quotient is stored to {qp, (ns - ds) + 1}. The remainder is always stored to {rp, ds}."],["divrem_1","Divides the `xs` least-significant limbs at `xp` by `d`, storing the result in {qp, qxn + xs}."],["divrem_2",""],["gcd",""],["incr",""],["is_zero","Checks that all `nn` limbs in `np` are zero"],["mul","Multiplies `{xp, xs}` by `{yp, ys}`, storing the result to `{wp, xs + ys}`."],["mul_1","Multiplies the `n` least-significant limbs of `xp` by `vl` storing the `n` least-significant limbs of the product in `{wp, n}`."],["nand_n","Performs a bitwise \"nand\" of the n least signficant limbs of `xp` and `yp`, storing the result in `wp`"],["nor_n","Performs a bitwise \"nor\" of the n least signficant limbs of `xp` and `yp`, storing the result in `wp`"],["normalize","Returns the size of the integer pointed to by `p` such that the most significant limb is non-zero."],["not","Performs a bitwise inversion (\"not\") of the n least signficant limbs of `xp`, storing the result in `wp`"],["or_n","Performs a bitwise \"or\" (`|`) of the n least signficant limbs of `xp` and `yp`, storing the result in `wp`"],["or_not_n","Performs a bitwise \"or\" of the n least signficant limbs of `xp` and `yp`, with the limbs of `yp` being first inverted. The result is stored in `wp`."],["overlap",""],["same_or_decr",""],["same_or_incr",""],["same_or_separate",""],["scan_0","Scans for the first 0 bit starting from the least-significant bit the the most, returning the bit index."],["scan_1","Scans for the first 1 bit starting from the least-significant bit the the most, returning the bit index."],["shl","Performs a bit-shift of the limbs in {xp, xs}, left by `cnt` bits storing the result in {rp, rs}. The top-most shifted bits are returned."],["shr","Performs a bit-shift of the limbs in {xp, xs}, right by `cnt` bits storing the result in {rp, rs}. The bottom-most shifted bits are returned."],["sqr","Squares the number in `{xp, xs}` storing the result in `{wp, xs*2}`. This is slightly more efficient than regular multiplication with both inputs the same."],["sub",""],["sub_1",""],["sub_n","Subtracts the `n` least signficant limbs of `yp` from `xp`, storing the result in {wp, n}. If there was a borrow from a higher-limb (i.e., the result would be negative), it is returned."],["submul_1","Multiplies the `n` least-signficiant digits of `xp` by `vl` and subtracts them from the `n` least-significant digits of `wp`. Returns the highest limb of the result, adjust for borrow."],["twos_complement","Computes the two's complement of the `xs` least significant words of `xp`. The result is stored the result in `wp`, and a carry is returned, if there is one."],["xor_n","Performs a bitwise \"xor\" (`^`) of the n least signficant limbs of `xp` and `yp`, storing the result in `wp`"],["zero",""]],"mod":[["base","Base conversion utilities"],["limb",""],["limb_ptr",""],["pow",""]]});